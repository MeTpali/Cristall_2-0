// Название файла: Frame.cpp
// Описание: Реализация методов класса Frame, отвечающего за отрисовку графических объектов.
//           Включает методы для отрисовки (обычная отрисовка, метод Вейлера, метод Гуро, Z-буфер)
//           и обработку события перерисовки окна.
// Создатели: Капланов Э.Т, Блудов Н.А, Папуашвили Г.Д., Терещук А.А, Шилин И.С.
// Дата создания: 16.10.2024
// Дата изменения: 20.10.2024

#include "Frame.h" // Подключаем заголовочный файл Frame.h

/*********************************************************************
  Функция: Frame (конструктор)
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Конструктор класса Frame, инициализирует QImage для холста, на котором будет выполняться отрисовка.
  Входные данные: указатель на родительский виджет
  Выходные данные: отсутствуют
**********************************************************************/
Frame::Frame(QWidget *parent) : QWidget(parent) // Конструктор класса Frame, наследуется от QWidget
{
    // Инициализируем QImage (холст) для отрисовки с прозрачным фоном (ARGB32)
    screen = QImage(widthCanvas, heightCanvas, QImage::Format_ARGB32);
}

/*********************************************************************
  Функция: paintEvent
  Дата создания: 16.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Обрабатывает событие перерисовки окна и отрисовывает содержимое на холсте.
  Входные данные: QPaintEvent *event — объект события отрисовки
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event); // Указываем, что переменная event не используется (для избежания предупреждений компилятора)

    QPainter painter(this);                                             // Инициализируем объект QPainter для отрисовки на текущем виджете
    QPen pen(Qt::black, 1, Qt::DashLine, Qt::SquareCap, Qt::RoundJoin); // Устанавливаем перо с параметрами (цвет: чёрный, толщина: 1, тип линии: пунктир)
    painter.setPen(pen);                                                // Устанавливаем перо для QPainter

    // Выбор способа отрисовки в зависимости от текущего значения optionDraw
    switch (optionDraw)
    {
    case 0:                         // Режим обычной отрисовки (по умолчанию)
        defaultDrawFigure(painter); // Вызываем метод отрисовки по умолчанию
        break;
    case 1:                         // Режим Z-буфера
        drawFigureZBuffer(painter); // Вызываем метод отрисовки по Z-буферу
        break;
    case 2:                        // Режим Вейлера
        drawFigureVeyler(painter); // Вызываем метод отрисовки по методу Вейлера
        break;
    case 3:                      // Режим Гуро
        drawFigureGuro(painter); // Вызываем метод отрисовки по методу Гуро
        break;
    }
}

/*********************************************************************
  Функция: defaultDrawFigure
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Выполняет стандартную отрисовку всех полигонов на canvas.
  Входные данные: QPainter &painter — объект QPainter для отрисовки
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::defaultDrawFigure(QPainter &painter)
{
    // Проходим по всем полигонам в списке
    for (int i = 0; i < dataPolygons.size(); i++)
    {
        // Массив точек для текущего полигона
        QPointF points[dataPolygons[i].size()];

        // Проходим по всем точкам текущего полигона
        for (int j = 0; j < dataPolygons[i].size(); j++)
        {
            // Получаем координаты точки с учётом центра экрана
            points[j] = QPointF(dataPoints[dataPolygons[i][j]].x() + widthCanvas / 2,
                                dataPoints[dataPolygons[i][j]].y() + heightCanvas / 2);
        }

        // Отрисовываем полигон с использованием массива точек
        painter.drawPolygon(points, dataPolygons[i].size());
    }
}

/*********************************************************************
  Функция: drawFigureZBuffer
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Отрисовывает полигоны на canvas методом Z-буфера.
  Входные данные: QPainter &painter — объект QPainter для отрисовки
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::drawFigureZBuffer(QPainter &painter)
{
    // Очищаем экран, заливая его белым цветом
    screen.fill(QColor(Qt::white).rgb());

    // Инициализируем буферы Z и кадра
    for (uint x = 0; x < widthCanvas; x++)
    {
        for (uint y = 0; y < heightCanvas; y++)
        {
            buffFrame[x][y] = 0; // Сбрасываем буфер кадра
            buffZ[x][y] = -1000; // Устанавливаем минимальное значение Z для всех пикселей
        }
    }

    // Проходим по всем полигонам
    for (int i = 0; i < dataPolygons.size(); i++)
    {
        QVector<intCoord> points; // Вектор для хранения координат вершин полигона
        for (int j = 0; j < dataPolygons[i].size(); j++)
        {
            // Получаем координаты точки с учётом центра экрана и округляем до целых значений
            points.push_back({int(dataPoints[dataPolygons[i][j]].x() + widthCanvas / 2 + 0.5),
                              int(dataPoints[dataPolygons[i][j]].y() + heightCanvas / 2 + 0.5),
                              dataPoints[dataPolygons[i][j]].z()});
        }

        // Вызываем функцию для заливки полигона методом Z-буфера
        fillPolygon(i + 1, points);
    }

    // Отображаем изображение на canvas
    painter.drawImage(1, 1, screen);
}

/*********************************************************************
  Функция: fillPolygon
  Дата создания: 16.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Заливает полигон на canvas с использованием Z-буфера.
  Входные данные:
    int idSegment — уникальный идентификатор текущего полигона
    QVector<intCoord> &points — вектор координат вершин полигона
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::fillPolygon(int idSegment, QVector<intCoord> &points)
{
    QMap<int, QVector<intCoord>> boundMap; // Словарь для границ полигона по оси X

    // Проходим по всем рёбрам полигона
    for (int i = 0; i < points.size() - 1; customLine(idSegment, points[i], points[i + 1], boundMap), i++)
        ;

    // Замыкаем последний отрезок полигона, соединяя последнюю точку с первой
    customLine(idSegment, points.last(), points[0], boundMap);

    // Проходим по всем горизонтальным отрезкам в словаре boundMap
    foreach (int key, boundMap.keys())
    {
        QVector<intCoord> value = boundMap.value(key); // Получаем координаты Y для текущего X
        for (int i = value[0].y; i < value[1].y; i++)  // Проходим по всем Y-координатам на текущей линии
        {
            if (buffFrame[key][i] != idSegment) // Если текущий пиксель ещё не заполнен этим полигоном
            {
                // Линейно интерполируем Z-координату для текущего пикселя
                double tmp = value[0].z + double(value[1].z - value[0].z) * double(double(i - value[0].y) / double(value[1].y - value[0].y));

                // Проверяем, ближе ли текущая Z-координата, чем та, что уже в буфере
                if (tmp >= buffZ[key][i])
                {
                    buffFrame[key][i] = 0; // Сбрасываем идентификатор полигона для текущего пикселя

                    // Устанавливаем цвет пикселя, если он находится в пределах экрана
                    if (key >= 0 && key < widthCanvas && i >= 0 && i < heightCanvas)
                    {
                        screen.setPixel(key, i, 4294967295); // Устанавливаем цвет пикселя (белый)
                    }

                    buffZ[key][i] = tmp; // Обновляем Z-буфер текущей координаты
                }
            }
        }
    }
}

/*********************************************************************
  Функция: customLine
  Дата создания: 16.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Рисует линию между двумя точками p1 и p2 с использованием алгоритма Брезенхэма.
           Также обновляет буфер глубины (Z-буфер) и обновляет границы полигона.
  Входные данные:
    int idSegment — уникальный идентификатор текущего полигона
    intCoord &p1 — начальная точка линии
    intCoord &p2 — конечная точка линии
    QMap<int, QVector<intCoord>> &boundMap — словарь для отслеживания границ полигона
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::customLine(int idSegment, intCoord &p1, intCoord &p2, QMap<int, QVector<intCoord>> &boundMap)
{
    // Проверка выхода за границы холста для начальной и конечной точек
    if (p1.x < 0 || p1.x >= widthCanvas || p1.y < 0 || p1.y >= heightCanvas ||
        p2.x < 0 || p2.x >= widthCanvas || p2.y < 0 || p2.y >= heightCanvas)
    {
        return; // Если хотя бы одна из точек за границей холста, завершаем выполнение функции
    }

    const int deltaX = abs(p2.x - p1.x);    // Разница по оси X
    const int deltaY = abs(p2.y - p1.y);    // Разница по оси Y
    const int signX = p1.x < p2.x ? 1 : -1; // Определяем направление изменения X (вправо или влево)
    const int signY = p1.y < p2.y ? 1 : -1; // Определяем направление изменения Y (вверх или вниз)
    int error = deltaX - deltaY;            // Инициализация ошибки для алгоритма Брезенхэма
    int x = p1.x, y = p1.y;                 // Начальные координаты текущей точки
    double tmp;                             // Переменная для хранения значения Z на текущей позиции

    // Цикл, пока текущая точка не совпадёт с конечной точкой
    while (x >= 0 && x < widthCanvas && y >= 0 && y < heightCanvas && (x != p2.x || y != p2.y))
    {
        // Вычисление Z-координаты на текущей точке путём линейной интерполяции
        if (p1.x == p2.x) // Если линия вертикальная
        {
            if (p1.y != p2.y)
            {
                tmp = p1.z + double(p2.z - p1.z) * double(double(y - p1.y) / double(p2.y - p1.y)); // Интерполяция Z по оси Y
            }
            else
            {
                tmp = p1.z; // Если точки совпадают по X и Y, берём Z-координату из p1
            }
        }
        else
        {
            tmp = p1.z + double(p2.z - p1.z) * double(double(x - p1.x) / double(p2.x - p1.x)); // Интерполяция Z по оси X
        }

        // Проверка выхода за границы холста
        if (x >= 0 && x < widthCanvas && y >= 0 && y < heightCanvas)
        {
            // Сравниваем текущую Z-координату с Z-буфером
            if (tmp >= buffZ[x][y]) // Если текущая Z больше или равна записанной Z в буфере
            {
                buffFrame[x][y] = idSegment;            // Устанавливаем идентификатор текущего полигона
                screen.setPixelColor(x, y, 4278190080); // Устанавливаем цвет пикселя (цвет: #FF000000 — полностью чёрный)
                buffZ[x][y] = tmp;                      // Обновляем Z-буфер
            }
        }

        // Обновляем границы полигона для текущего X
        if (y >= 0 && y < heightCanvas)
        {
            if (boundMap.find(x) == boundMap.end()) // Если для текущего X ещё не заданы границы
            {
                intCoord boundCoord = {y, static_cast<int>(tmp)}; // Создаём начальные координаты для Y и Z
                boundMap.insert(x, {boundCoord, boundCoord});     // Устанавливаем начальные и конечные границы одинаковыми
            }
            else
            {
                if (boundMap[x][0].y > y) // Обновляем верхнюю границу по Y
                {
                    boundMap[x][0].y = y;   // Устанавливаем новую верхнюю границу
                    boundMap[x][0].z = tmp; // Устанавливаем новую Z-координату
                }
                else if (boundMap[x][1].y < y) // Обновляем нижнюю границу по Y
                {
                    boundMap[x][1].y = y;   // Устанавливаем новую нижнюю границу
                    boundMap[x][1].z = tmp; // Устанавливаем новую Z-координату
                }
            }
        }

        // Алгоритм Брезенхэма для вычисления следующей точки линии
        const int error2 = error * 2; // Удваиваем ошибку
        if (error2 > -deltaY)         // Проверяем отклонение по X
        {
            error -= deltaY; // Уменьшаем ошибку на разницу по Y
            x += signX;      // Сдвигаемся по оси X в нужную сторону
        }
        if (error2 < deltaX) // Проверяем отклонение по Y
        {
            error += deltaX; // Увеличиваем ошибку на разницу по X
            y += signY;      // Сдвигаемся по оси Y в нужную сторону
        }
    }
}

/*********************************************************************
  Функция: getPlaneZCoord
  Дата создания: 16.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Вычисляет Z-координату точки (x, y) на плоскости, заданной тремя точками.
  Входные данные:
    double x — координата X точки, для которой нужно вычислить Z
    double y — координата Y точки, для которой нужно вычислить Z
    const QVector3D &a — первая точка на плоскости
    const QVector3D &b — вторая точка на плоскости
    const QVector3D &c — третья точка на плоскости
  Выходные данные: возвращает координату Z для точки (x, y)
**********************************************************************/
double getPlaneZCoord(double x, double y, const QVector3D &a, const QVector3D &b, const QVector3D &c)
{
    // Векторы на плоскости, определяем два вектора от точки a к b и от точки a к c
    QVector3D AB = b - a;
    QVector3D AC = c - a;

    // Нормаль к плоскости через векторное произведение двух векторов
    QVector3D normal = QVector3D::crossProduct(AB, AC);

    // Проверка, чтобы нормаль не была параллельна оси Z (избегаем деления на ноль)
    if (std::abs(normal.z()) < 1e-7)
    {
        // Плоскость параллельна оси Z, возвращаем большое отрицательное значение
        return -1e9;
    }

    // Уравнение плоскости: Ax + By + Cz + D = 0
    double A = normal.x();
    double B = normal.y();
    double C = normal.z();
    double D = -QVector3D::dotProduct(normal, a); // Подставляем точку a в уравнение плоскости

    // Вычисляем Z для заданных X и Y по уравнению плоскости
    double z = (-A * x - B * y - D) / C;
    return z; // Возвращаем Z-координату
}

/*********************************************************************
  Структура: PolyZ
  Описание: Содержит индекс полигона и среднюю Z-координату полигона.
**********************************************************************/
struct PolyZ
{
    int idx;     // Индекс полигона
    double avgZ; // Средняя Z-координата полигона
};

/*********************************************************************
  Функция: drawFigureVeyler
  Дата создания: 16.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Отрисовывает полигоны на canvas с использованием алгоритма Вейлера-Атертона.
  Входные данные:
    QPainter &painter — объект QPainter для отрисовки
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::drawFigureVeyler(QPainter &painter)
{
    // Очищаем буфер вывода, заполняя его белым цветом
    screen.fill(QColor(Qt::white).rgb());

    // Устанавливаем параметры кисти и заливки
    QBrush brush(Qt::white);          // Устанавливаем кисть белого цвета
    brush.setStyle(Qt::SolidPattern); // Сплошная заливка
    painter.setBrush(brush);          // Применяем кисть к объекту painter

    // Создаём вектор структур PolyZ для всех полигонов
    QVector<PolyZ> ZCoords;
    ZCoords.reserve(dataPolygons.size()); // Резервируем память для всех полигонов

    // Вычисление средней координаты Z для каждого полигона
    for (size_t i = 0; i < dataPolygons.size(); ++i)
    {
        const auto &polygon = dataPolygons[i]; // Получаем текущий полигон
        double sumZ = 0.0;                     // Переменная для суммы Z-координат
        int count = 0;                         // Счётчик количества вершин в полигоне

        // Суммируем Z-координаты всех вершин полигона
        for (const auto &pointIdx : polygon)
        {
            const QVector3D &point = dataPoints[pointIdx]; // Получаем координаты текущей точки
            sumZ += point.z();                             // Добавляем Z-координату к сумме
            ++count;                                       // Увеличиваем счётчик
        }

        double averageZ = (count > 0) ? (sumZ / count) : 0.0; // Средняя Z-координата полигона

        // Добавляем полигон и его среднюю Z-координату в вектор ZCoords
        ZCoords.push_back(PolyZ{static_cast<int>(i), averageZ});
    }

    // Сортируем полигоны по средней Z-координате (от дальних к ближним)
    std::sort(ZCoords.begin(), ZCoords.end(),
              [](const PolyZ &a, const PolyZ &b) -> bool
              {
                  return a.avgZ < b.avgZ; // Сначала идут полигоны с меньшей Z
              });

    // Отрисовываем полигоны от дальних к ближним
    for (const auto &polyZ : ZCoords)
    {
        int idx = polyZ.idx;                     // Получаем индекс текущего полигона
        const auto &polygon = dataPolygons[idx]; // Получаем текущий полигон по индексу

        // Создаём массив точек для полигона с учётом смещения центра экрана
        QVector<QPointF> points;
        points.reserve(polygon.size()); // Резервируем память для точек полигона
        for (const auto &pointIdx : polygon)
        {
            const QVector3D &point = dataPoints[pointIdx]; // Получаем координаты точки
            // Преобразуем координаты точки с учётом центра экрана
            QPointF screenPoint(point.x() + widthCanvas / 2.0,
                                point.y() + heightCanvas / 2.0);
            points.append(screenPoint); // Добавляем точку в массив точек полигона
        }

        // Отрисовываем текущий полигон
        painter.drawPolygon(points.data(), points.size());
    }
}

/*********************************************************************
  Функция: mouseMoveEvent
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Обрабатывает перемещение мыши и поворачивает объект при её движении.
  Входные данные:
    QMouseEvent *event — событие перемещения мыши
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::mouseMoveEvent(QMouseEvent *event)
{
    if (!_p.isNull()) // Проверяем, было ли нажатие мыши
    {
        // Проверяем, что сдвиг по осям X и Y больше 5 пикселей
        if (abs(rotationX - (event->x() - int(widthCanvas / 2))) > 5 &&
            abs(rotationY - (event->y() - int(heightCanvas / 2))) > 5)
        {
            // Определяем направление перемещения по X и Y
            if (rotationX > (event->x() - int(widthCanvas / 2)))
            {
                if (rotationY > (event->y() - int(heightCanvas / 2)))
                {
                    if (FiX > 0)
                        FiX = -FiX; // Инвертируем угол по оси X
                    rotateX(false); // Поворот по оси X
                    FiY = abs(FiY); // Делаем угол по оси Y положительным
                    rotateY(false); // Поворот по оси Y
                }
                else
                {
                    FiX = abs(FiX); // Делаем угол по оси X положительным
                    rotateX(false); // Поворот по оси X
                    FiY = abs(FiY); // Делаем угол по оси Y положительным
                    rotateY(false); // Поворот по оси Y
                }
            }
            else
            {
                if (rotationY > (event->y() - int(heightCanvas / 2)))
                {
                    if (FiX > 0)
                        FiX = -FiX; // Инвертируем угол по оси X
                    rotateX(false); // Поворот по оси X
                    if (FiY > 0)
                        FiY = -FiY; // Инвертируем угол по оси Y
                    rotateY(false); // Поворот по оси Y
                }
                else
                {
                    FiX = abs(FiX); // Делаем угол по оси X положительным
                    rotateX(false); // Поворот по оси X
                    if (FiY > 0)
                        FiY = -FiY; // Инвертируем угол по оси Y
                    rotateY(false); // Поворот по оси Y
                }
            }

            // Обновляем значения текущих координат для поворота
            rotationX = event->x() - int(widthCanvas / 2);
            rotationY = event->y() - int(heightCanvas / 2);
        }
    }
    repaint(); // Перерисовываем canvas
}

/*********************************************************************
  Функция: rotateZLeft
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Поворачивает объект влево вокруг оси Z.
  Входные данные: отсутствуют
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::rotateZLeft()
{
    rotateZ("Left", true); // Вызов функции поворота с параметрами направления и перерисовки
}

/*********************************************************************
  Функция: rotateZRight
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Поворачивает объект вправо вокруг оси Z.
  Входные данные: отсутствуют
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::rotateZRight()
{
    rotateZ("Right", true); // Вызов функции поворота с параметрами направления и перерисовки
}

/*********************************************************************
  Функция: rotateX
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Поворачивает объект вокруг оси X на заданный угол.
  Входные данные:
    bool b_repaint — флаг, определяющий, нужно ли перерисовывать canvas после поворота
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::rotateX(bool b_repaint)
{
    // Матрица поворота вокруг оси X
    QMatrix4x4 R(
        1, 0, 0, 0,
        0, cos(FiX), sin(FiX), 0,
        0, -sin(FiX), cos(FiX), 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    if (b_repaint)
        repaint(); // Перерисовываем canvas, если флаг b_repaint установлен
}

/*********************************************************************
  Функция: rotateY
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Поворачивает объект вокруг оси Y на заданный угол.
  Входные данные:
    bool b_repaint — флаг, определяющий, нужно ли перерисовывать canvas после поворота
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::rotateY(bool b_repaint)
{
    // Матрица поворота вокруг оси Y
    QMatrix4x4 R(
        cos(FiY), 0, -sin(FiY), 0,
        0, 1, 0, 0,
        sin(FiY), 0, cos(FiY), 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    if (b_repaint)
        repaint(); // Перерисовываем canvas, если флаг b_repaint установлен
}

/*********************************************************************
  Функция: rotateZ
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Поворачивает объект вокруг оси Z в заданном направлении.
  Входные данные:
    QString direction — направление поворота ("Left" или "Right")
    bool b_repaint — флаг, определяющий, нужно ли перерисовывать canvas после поворота
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::rotateZ(QString direction, bool b_repaint)
{
    if (direction == "Left")
    {
        FiZ = abs(FiZ); // Устанавливаем положительное значение угла FiZ
    }
    else if (direction == "Right")
    {
        if (FiZ > 0)
            FiZ = -FiZ; // Инвертируем угол FiZ для поворота вправо
    }

    // Матрица поворота вокруг оси Z
    QMatrix4x4 R(
        cos(FiZ), sin(FiZ), 0, 0,
        -sin(FiZ), cos(FiZ), 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    if (b_repaint)
        repaint(); // Перерисовываем canvas, если флаг b_repaint установлен
}

/*********************************************************************
  Функция: onRotateX
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Поворачивает объект вокруг оси X на заданный угол.
  Входные данные:
    double turn — угол поворота в градусах
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::onRotateX(double turn)
{
    double angle = turn * M_PI / 180; // Конвертируем угол из градусов в радианы

    // Матрица поворота вокруг оси X
    QMatrix4x4 R(
        1, 0, 0, 0,
        0, cos(angle), sin(angle), 0,
        0, -sin(angle), cos(angle), 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: onRotateY
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Поворачивает объект вокруг оси Y на заданный угол.
  Входные данные:
    double turn — угол поворота в градусах
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::onRotateY(double turn)
{
    double angle = turn * M_PI / 180; // Конвертируем угол из градусов в радианы

    // Матрица поворота вокруг оси Y
    QMatrix4x4 R(
        cos(angle), 0, -sin(angle), 0,
        0, 1, 0, 0,
        sin(angle), 0, cos(angle), 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: onRotateZ
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Поворачивает объект вокруг оси Z на заданный угол.
  Входные данные:
    double turn — угол поворота в градусах
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::onRotateZ(double turn)
{
    double angle = turn * M_PI / 180; // Конвертируем угол из градусов в радианы

    // Матрица поворота вокруг оси Z
    QMatrix4x4 R(
        cos(angle), sin(angle), 0, 0,
        -sin(angle), cos(angle), 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: scaleX
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Масштабирует объект по оси X.
  Входные данные:
    double scaleValue — коэффициент масштабирования
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::scaleX(double scaleValue)
{
    // Матрица масштабирования по оси X
    QMatrix4x4 R(
        scaleValue, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: scaleY
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Масштабирует объект по оси Y.
  Входные данные:
    double scaleValue — коэффициент масштабирования
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::scaleY(double scaleValue)
{
    // Матрица масштабирования по оси Y
    QMatrix4x4 R(
        1, 0, 0, 0,
        0, scaleValue, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: scaleZ
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Масштабирует объект по оси Z.
  Входные данные:
    double scaleValue — коэффициент масштабирования
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::scaleZ(double scaleValue)
{
    // Матрица масштабирования по оси Z
    QMatrix4x4 R(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, scaleValue, 0,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: moveToCoord
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Перемещает объект на заданные координаты.
  Входные данные:
    double posX — координата смещения по оси X
    double posY — координата смещения по оси Y
    double posZ — координата смещения по оси Z
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::moveToCoord(double posX, double posY, double posZ)
{
    // Матрица переноса (сдвига) объекта
    QMatrix4x4 R(
        1, 0, 0, posX,
        0, 1, 0, posY,
        0, 0, 1, posZ,
        0, 0, 0, 1);

    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: reflectX
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Отражает объект относительно оси X.
  Входные данные: отсутствуют
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::reflectX()
{
    // Матрица отражения относительно оси X
    QMatrix4x4 R(
        1, 0, 0, 0,
        0, -1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);
    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: reflectY
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Отражает объект относительно оси Y.
  Входные данные: отсутствуют
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::reflectY()
{
    // Матрица отражения относительно оси Y
    QMatrix4x4 R(
        -1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);
    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: reflectZ
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Отражает объект относительно оси Z.
  Входные данные: отсутствуют
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::reflectZ()
{
    // Матрица отражения относительно оси Z
    QMatrix4x4 R(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, -1, 0,
        0, 0, 0, 1);
    calculate(R); // Вычисляем новые координаты вершин
    repaint();    // Перерисовываем canvas
}

/*********************************************************************
  Функция: calculate
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Применяет матрицу преобразования к каждой точке объекта.
  Входные данные:
    QMatrix4x4 &R — матрица преобразования
  Выходные данные: отсутствуют
**********************************************************************/
void Frame::calculate(QMatrix4x4 &R)
{
    for (int i = 0; i < dataPoints.size(); i++)
    {
        // Преобразуем точку в однородные координаты (x, y, z, 1)
        QVector4D vectCoord(dataPoints[i].x(), dataPoints[i].y(), dataPoints[i].z(), 1);

        // Умножаем матрицу R на вектор координат
        QVector4D result = R * vectCoord;

        // Присваиваем новые значения координат
        dataPoints[i].setX(result[0]);
        dataPoints[i].setY(result[1]);
        dataPoints[i].setZ(result[2]);
    }
}

/*********************************************************************
  Функция: upload
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Загружает данные из файлов точек и полигонов.
  Входные данные:
    QString initPathPolygons — путь к файлу с полигонами
    QString initPathPoints — путь к файлу с точками
  Выходные данные: bool — true, если загрузка успешна, иначе false
**********************************************************************/
bool Frame::upload(QString initPathPolygons, QString initPathPoints)
{
    pathPolygons = initPathPolygons; // Устанавливаем путь к файлу полигонов
    pathPoints = initPathPoints;     // Устанавливаем путь к файлу точек

    // Заполняем данные о полигонах и точках
    bool resultFillPolygons = fillingDataPolygons();
    bool resultFillPoints = fillingDataPoints();

    if (resultFillPolygons && resultFillPoints)
        return true; // Если загрузка успешна, возвращаем true

    repaint();    // Перерисовываем canvas
    return false; // Если загрузка не удалась, возвращаем false
}

/*********************************************************************
  Функция: fillingDataPolygons
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Считывает данные о полигонах из файла.
  Входные данные: отсутствуют
  Выходные данные: bool — true, если данные успешно считаны, иначе false
**********************************************************************/
bool Frame::fillingDataPolygons()
{
    dataPolygons.clear(); // Очищаем текущие данные о полигонах

    QFile file(pathPolygons); // Открываем файл с полигонами
    if (!file.open(QIODevice::ReadOnly))
    {
        // Показываем предупреждение, если файл не найден
        QMessageBox::warning(this, "Предупреждение!", "Файл " + pathPolygons + " не найден!");
        return false; // Завершаем функцию с результатом false
    }

    while (!file.atEnd())
    {
        QStringList list;
        QString tmpStr = file.readLine();             // Считываем строку из файла
        list = tmpStr.split(QRegularExpression(" ")); // Разделяем строку по пробелам

        QVector<int> tmpVec;
        for (int i = 1; i <= list.at(0).toInt(); i++)
        {
            tmpVec.push_back(list.at(i).toInt()); // Добавляем индексы вершин полигона
        }

        dataPolygons.push_back(tmpVec); // Добавляем полигон в список
    }

    file.close(); // Закрываем файл
    return true;  // Данные успешно считаны, возвращаем true
}

/*********************************************************************
  Функция: fillingDataPoints
  Дата создания: 16.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Считывает данные о точках из файла.
  Входные данные: отсутствуют
  Выходные данные: bool — true, если данные успешно считаны, иначе false
**********************************************************************/
bool Frame::fillingDataPoints()
{
    dataPoints.clear(); // Очищаем текущие данные о точках

    QFile file(pathPoints); // Открываем файл с точками
    if (!file.open(QIODevice::ReadOnly))
    {
        // Показываем предупреждение, если файл не найден
        QMessageBox::warning(this, "Предупреждение!", "Файл " + pathPoints + " не найден!");
        return false; // Завершаем функцию с результатом false
    }

    while (!file.atEnd())
    {
        QStringList list;
        QString tmp = file.readLine();             // Считываем строку из файла
        list = tmp.split(QRegularExpression(" ")); // Разделяем строку по пробелам

        // Добавляем точку, умножая координаты на 100 для увеличения масштаба
        dataPoints.push_back({100 * list[0].toFloat(), 100 * list[1].toFloat(), 100 * list[2].toFloat()});
    }

    file.close(); // Закрываем файл
    return true;  // Данные успешно считаны, возвращаем true
}

/*********************************************************************
  Функция: getCanvasWidth
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Возвращает ширину canvas.
  Входные данные: отсутствуют
  Выходные данные: int — ширина canvas
**********************************************************************/
int Frame::getCanvasWidth()
{
    return widthCanvas; // Возвращаем ширину canvas
}

/*********************************************************************
  Функция: getCanvasHeight
  Дата создания: 16.10.2024
  Дата последних изменений: 18.10.2024
  Описание: Возвращает высоту canvas.
  Входные данные: отсутствуют
  Выходные данные: int — высота canvas
**********************************************************************/
int Frame::getCanvasHeight()
{
    return heightCanvas; // Возвращаем высоту canvas
}

// Структура для хранения нормали полигона
struct PolygonNormal
{
    QVector3D normal; // Нормаль полигона
};

// Структура для хранения нормали вершины
struct VertexNormal
{
    QVector3D normal; // Нормаль вершины
};

// Структура для хранения интенсивности вершины
struct VertexIntensity
{
    double intensity; // Интенсивность освещения в вершине
};

// Структура для хранения треугольника с интенсивностями
struct ShadedTriangle
{
    QVector3D v0; // Первая вершина треугольника
    QVector3D v1; // Вторая вершина треугольника
    QVector3D v2; // Третья вершина треугольника
    double i0;    // Интенсивность в первой вершине
    double i1;    // Интенсивность во второй вершине
    double i2;    // Интенсивность в третьей вершине
};

/*********************************************************************
  Функция: computeNormal
  Дата создания: 18.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Вычисляет нормаль к треугольнику, заданному тремя точками.
  Входные данные:
    QVector3D a — первая вершина треугольника
    QVector3D b — вторая вершина треугольника
    QVector3D c — третья вершина треугольника
  Выходные данные: QVector3D — нормализованная нормаль к треугольнику
**********************************************************************/
QVector3D computeNormal(const QVector3D &a, const QVector3D &b, const QVector3D &c)
{
    // Вычисляем два вектора на плоскости треугольника
    QVector3D u = b - a;
    QVector3D v = c - a;

    // Вычисляем векторное произведение (нормаль) и нормализуем его
    QVector3D normal = QVector3D::crossProduct(u, v).normalized();
    return normal; // Возвращаем нормализованную нормаль
}

/*********************************************************************
  Функция: computePolygonNormals
  Дата создания: 18.10.2024
  Дата последних изменений: 19.10.2024
  Описание: Вычисляет нормали для всех полигонов.
  Входные данные:
    QVector<QVector<int>> dataPolygons — данные о полигонах
    QVector<QVector3D> dataPoints — координаты точек
  Выходные данные: QVector<PolygonNormal> — нормали для всех полигонов
**********************************************************************/
QVector<PolygonNormal> computePolygonNormals(const QVector<QVector<int>> &dataPolygons, const QVector<QVector3D> &dataPoints)
{
    QVector<PolygonNormal> polygonNormals;       // Список нормалей для полигонов
    polygonNormals.reserve(dataPolygons.size()); // Резервируем место для нормалей

    for (const auto &poly : dataPolygons)
    {
        if (poly.size() < 3)
        {
            // Если полигон содержит меньше трёх вершин, добавляем нулевую нормаль
            polygonNormals.append(PolygonNormal{QVector3D(0, 0, 0)});
            continue;
        }

        // Берём первые три точки полигона для вычисления нормали
        QVector3D a = dataPoints[poly[0]];
        QVector3D b = dataPoints[poly[1]];
        QVector3D c = dataPoints[poly[2]];

        // Вычисляем нормаль к треугольнику, который образуют эти три точки
        QVector3D normal = computeNormal(a, b, c);

        // Добавляем нормаль в список нормалей
        polygonNormals.append(PolygonNormal{normal});
    }

    return polygonNormals; // Возвращаем список нормалей для всех полигонов
}

/*********************************************************************
  Функция: computeVertexNormals
  Дата создания: 19.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Вычисляет нормали для всех вершин на основе нормалей всех полигонов.
  Входные данные:
    QVector<QVector<int>> dataPolygons — полигоны (список индексов вершин)
    QVector<PolygonNormal> polygonNormals — нормали всех полигонов
    int numVertices — количество вершин
  Выходные данные: QVector<VertexNormal> — нормали для всех вершин
**********************************************************************/
QVector<VertexNormal> computeVertexNormals(const QVector<QVector<int>> &dataPolygons, const QVector<PolygonNormal> &polygonNormals, int numVertices)
{
    QVector<QVector3D> tempNormals(numVertices, QVector3D(0, 0, 0)); // Временное хранилище для суммирования нормалей вершин
    QVector<int> counts(numVertices, 0);                             // Счётчик количества полигонов, к которым принадлежит каждая вершина

    // Суммируем нормали всех полигонов, которым принадлежит вершина
    for (size_t i = 0; i < dataPolygons.size(); ++i)
    {
        const auto &poly = dataPolygons[i];                 // Полигон
        const QVector3D &normal = polygonNormals[i].normal; // Нормаль текущего полигона

        for (int vertexIdx : poly) // Для каждой вершины в полигоне
        {
            tempNormals[vertexIdx] += normal; // Добавляем нормаль полигона к нормали вершины
            counts[vertexIdx]++;              // Увеличиваем счётчик для текущей вершины
        }
    }

    // Усредняем нормали вершин
    QVector<VertexNormal> vertexNormals;
    vertexNormals.reserve(numVertices); // Резервируем память для нормалей всех вершин

    for (int i = 0; i < numVertices; ++i)
    {
        if (counts[i] > 0) // Если вершина принадлежит хотя бы одному полигону
        {
            QVector3D avgNormal = tempNormals[i] / static_cast<float>(counts[i]); // Усредняем нормаль
            avgNormal.normalize();                                                // Нормализуем усреднённую нормаль
            vertexNormals.append(VertexNormal{avgNormal});                        // Добавляем нормаль вершины в список
        }
        else
        {
            // Если вершина не принадлежит ни одному полигону, устанавливаем нормаль (0, 0, 0)
            vertexNormals.append(VertexNormal{QVector3D(0, 0, 0)});
        }
    }

    return vertexNormals; // Возвращаем список нормалей всех вершин
}

/*********************************************************************
  Функция: computeVertexIntensities
  Дата создания: 19.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Вычисляет интенсивность света для каждой вершины.
  Входные данные:
    QVector<VertexNormal> vertexNormals — нормали всех вершин
    QVector3D lightDirection — направление источника света
  Выходные данные: QVector<VertexIntensity> — интенсивности освещения для каждой вершины
**********************************************************************/
QVector<VertexIntensity> computeVertexIntensities(const QVector<VertexNormal> &vertexNormals, const QVector3D &lightDirection)
{
    QVector<VertexIntensity> vertexIntensities;
    vertexIntensities.reserve(vertexNormals.size()); // Резервируем память для интенсивностей вершин

    QVector3D normalizedLightDir = lightDirection.normalized(); // Нормализуем вектор направления света

    for (const auto &vNormal : vertexNormals) // Для каждой нормали вершины
    {
        // Диффузное освещение: интенсивность I = max(0, N • L), где N — нормаль вершины, L — вектор направления света
        double intensity = QVector3D::dotProduct(vNormal.normal, normalizedLightDir); // Скалярное произведение нормали и направления света
        intensity = std::max(0.0, static_cast<double>(intensity));                    // Устанавливаем минимум 0, чтобы исключить отрицательные значения
        vertexIntensities.append(VertexIntensity{intensity});                         // Добавляем интенсивность вершины в список
    }

    return vertexIntensities; // Возвращаем список интенсивностей для всех вершин
}

/*********************************************************************
  Функция: triangulateAndShade
  Дата создания: 20.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Выполняет триангуляцию выпуклого многоугольника и определяет интенсивности вершин для каждого треугольника.
  Входные данные:
    QVector<QVector3D> polygonVertices — вершины многоугольника
    QVector<VertexIntensity> vertexIntensities — интенсивности для каждой вершины
  Выходные данные: QVector<ShadedTriangle> — список треугольников с их вершинами и интенсивностями
**********************************************************************/
QVector<ShadedTriangle> triangulateAndShade(const QVector<QVector3D> &polygonVertices, const QVector<VertexIntensity> &vertexIntensities)
{
    QVector<ShadedTriangle> shadedTriangles;
    if (polygonVertices.size() < 3)
        return shadedTriangles;

    // Используем первую вершину как базовую
    QVector3D base = polygonVertices[0];
    double iBase = vertexIntensities[0].intensity;

    for (int i = 1; i < polygonVertices.size() - 1; ++i)
    {
        ShadedTriangle tri;
        tri.v0 = base;
        tri.v1 = polygonVertices[i];
        tri.v2 = polygonVertices[i + 1];
        tri.i0 = iBase;
        tri.i1 = vertexIntensities[i].intensity;
        tri.i2 = vertexIntensities[i + 1].intensity;
        shadedTriangles.append(tri);
    }

    return shadedTriangles;
}

/*********************************************************************
  Функция: interpolateIntensity
  Дата создания: 20.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Интерполирует интенсивность по барицентрическим координатам.
  Входные данные:
    double u, v, w — барицентрические координаты
    double i0, i1, i2 — интенсивности вершин треугольника
  Выходные данные: double — интерполированное значение интенсивности
**********************************************************************/
double interpolateIntensity(double u, double v, double w, double i0, double i1, double i2)
{
    return u * i0 + v * i1 + w * i2;
}

/*********************************************************************
  Функция: drawFigureGuro
  Дата создания: 20.10.2024
  Дата последних изменений: 20.10.2024
  Описание: Закрашивает фигуру методом Гуро с использованием барицентрической интерполяции интенсивности.
  Входные данные:
    QPainter &painter — ссылка на QPainter
    QVector<QVector<int>> dataPolygons — полигоны, представляющие индексы вершин
    QVector<QVector3D> dataPoints — вершины в 3D-пространстве
    QVector<VertexIntensity> vertexIntensities — интенсивности вершин
    int widthCanvas, heightCanvas — размеры холста
  Выходные данные: отсутствуют
**********************************************************************/
void drawFigureGuro(QPainter &painter, const QVector<QVector<int>> &dataPolygons, const QVector<QVector3D> &dataPoints, const QVector<VertexIntensity> &vertexIntensities, int widthCanvas, int heightCanvas)
{
    // Создаём буфер изображения
    QImage screen(widthCanvas, heightCanvas, QImage::Format_RGB32);
    screen.fill(Qt::black);

    // Создаём Z-буфер, инициализируем его минимально возможными значениями
    QVector<QVector<double>> zBuffer(widthCanvas, QVector<double>(heightCanvas, -std::numeric_limits<double>::infinity()));

    // Создаём вектор треугольников с интенсивностями
    QVector<ShadedTriangle> shadedTriangles;

    for (const auto &poly : dataPolygons)
    {
        if (poly.size() < 3)
            continue; // Пропускаем некорректные полигоны

        // Собираем вершины полигона
        QVector<QVector3D> polygonVertices;
        QVector<VertexIntensity> polygonIntensities;
        for (int idx : poly)
        {
            QVector3D point = dataPoints[idx];
            // Смещаем координаты относительно центра канвы
            point.setX(point.x() + widthCanvas / 2.0);
            point.setY(point.y() + heightCanvas / 2.0);
            polygonVertices.append(point);
            polygonIntensities.append(vertexIntensities[idx]);
        }

        // Триангулируем многоугольник и получаем закрашенные треугольники
        QVector<ShadedTriangle> tris = triangulateAndShade(polygonVertices, polygonIntensities);
        shadedTriangles.append(tris);
    }

    // Растеризация каждого закрашенного треугольника
    for (const auto &tri : shadedTriangles)
    {
        // Определяем границы треугольника
        int minX = std::floor(std::min({tri.v0.x(), tri.v1.x(), tri.v2.x()}));
        int maxX = std::ceil(std::max({tri.v0.x(), tri.v1.x(), tri.v2.x()}));
        int minY = std::floor(std::min({tri.v0.y(), tri.v1.y(), tri.v2.y()}));
        int maxY = std::ceil(std::max({tri.v0.y(), tri.v1.y(), tri.v2.y()}));

        // Ограничиваем границы экрана
        minX = std::max(minX, 0);
        maxX = std::min(maxX, widthCanvas - 1);
        minY = std::max(minY, 0);
        maxY = std::min(maxY, heightCanvas - 1);

        // Проходим по каждому пикселю в ограничивающем прямоугольнике
        for (int y = minY; y <= maxY; y++)
        {
            for (int x = minX; x <= maxX; x++)
            {
                // Используем центр пикселя для проверки принадлежности
                double px = x + 0.5;
                double py = y + 0.5;

                // Вычисляем барицентрические координаты
                double denom = (tri.v1.y() - tri.v2.y()) * (tri.v0.x() - tri.v2.x()) +
                               (tri.v2.x() - tri.v1.x()) * (tri.v0.y() - tri.v2.y());

                if (std::abs(denom) < 1e-9)
                    continue; // Треугольник вырожден

                double u = ((tri.v1.y() - tri.v2.y()) * (px - tri.v2.x()) +
                            (tri.v2.x() - tri.v1.x()) * (py - tri.v2.y())) /
                           denom;
                double v = ((tri.v2.y() - tri.v0.y()) * (px - tri.v2.x()) +
                            (tri.v0.x() - tri.v2.x()) * (py - tri.v2.y())) /
                           denom;
                double w = 1.0 - u - v;

                // Проверяем, принадлежит ли пиксель треугольнику
                if (u >= 0 && v >= 0 && w >= 0)
                {
                    // Интерполируем Z
                    double z = u * tri.v0.z() + v * tri.v1.z() + w * tri.v2.z();

                    // Проверяем Z-буфер
                    if (z > zBuffer[x][y])
                    {
                        zBuffer[x][y] = z;

                        // Интерполируем интенсивность
                        double intensity = interpolateIntensity(u, v, w, tri.i0, tri.i1, tri.i2);
                        intensity = std::clamp(intensity, 0.0, 1.0);

                        // Преобразуем интенсивность в оттенки серого
                        int gray = static_cast<int>(intensity * 255);
                        QColor color(gray, gray, gray);

                        // Устанавливаем цвет пикселя
                        screen.setPixelColor(x, y, color);
                    }
                }
            }
        }
    }

    // Отображаем готовое изображение
    painter.drawImage(0, 0, screen);
}
